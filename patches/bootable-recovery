diff --git a/Android.mk~ b/Android.mk~
new file mode 100644
index 0000000..e441da3
--- /dev/null
+++ b/Android.mk~
@@ -0,0 +1,361 @@
+# Copyright (C) 2007 The Android Open Source Project
+# Copyright (C) 2015 The CyanogenMod Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+ifeq ($(call my-dir),$(call project-path-for,recovery))
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := fuse_sideload.cpp
+LOCAL_CLANG := true
+LOCAL_CFLAGS := -O2 -g -DADB_HOST=0 -Wall -Wno-unused-parameter
+LOCAL_CFLAGS += -D_XOPEN_SOURCE -D_GNU_SOURCE
+
+LOCAL_MODULE := libfusesideload
+
+LOCAL_STATIC_LIBRARIES := libcutils libc libcrypto_static
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    adb_install.cpp \
+    asn1_decoder.cpp \
+    device.cpp \
+    fuse_sdcard_provider.cpp \
+    install.cpp \
+    recovery.cpp \
+    roots.cpp \
+    screen_ui.cpp \
+    ui.cpp \
+    verifier.cpp \
+    wear_ui.cpp \
+    wear_touch.cpp \
+    voldclient.cpp
+
+# External tools
+LOCAL_SRC_FILES += \
+    ../../system/core/toolbox/newfs_msdos.c \
+    ../../system/core/toolbox/start_stop.cpp \
+    ../../system/vold/vdc.cpp
+
+LOCAL_MODULE := recovery
+
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+
+RECOVERY_API_VERSION := 3
+RECOVERY_FSTAB_VERSION := 2
+LOCAL_CFLAGS += -DRECOVERY_API_VERSION=$(RECOVERY_API_VERSION)
+LOCAL_CFLAGS += -Wno-unused-parameter
+LOCAL_CLANG := false
+
+LOCAL_C_INCLUDES += \
+    system/vold \
+    system/extras/ext4_utils \
+    system/core/adb \
+    external/e2fsprogs/lib
+
+LOCAL_STATIC_LIBRARIES := \
+    libbatterymonitor \
+    libminivold_static \
+    libbootloader_message \
+    libext4_utils_static \
+    libmake_ext4fs_static \
+    libminizip_static \
+    libminiunz_static \
+    libsparse_static \
+    libfsck_msdos \
+    libminipigz_static \
+    libzopfli \
+    libreboot_static \
+    libsdcard \
+    libminzip \
+    libz \
+    libmtdutils \
+    libminadbd \
+    libtoybox_driver \
+    libmksh_static \
+    libfusesideload \
+    libminui \
+    libpng \
+    libf2fs_sparseblock \
+    libdiskconfig \
+    libsysutils \
+    libfs_mgr \
+    libcrypto_utils_static \
+    libcrypto_static \
+    libbase \
+    libutils \
+    liblog \
+    liblogwrap \
+    libselinux \
+    libscrypt_static \
+    libnl \
+    libc++_static \
+    libm \
+    libc \
+    libext2_blkid \
+    libext2_uuid \
+    libfec \
+    libfec_rs \
+    libsquashfs_utils
+
+LOCAL_HAL_STATIC_LIBRARIES := libhealthd
+LOCAL_WHOLE_STATIC_LIBRARIES += libcutils
+
+# OEMLOCK support requires a device specific liboemlock be supplied.
+# See comments in recovery.cpp for the API.
+ifeq ($(TARGET_HAVE_OEMLOCK), true)
+    LOCAL_CFLAGS += -DHAVE_OEMLOCK
+    LOCAL_STATIC_LIBRARIES += liboemlock
+endif
+
+ifeq ($(AB_OTA_UPDATER),true)
+    LOCAL_CFLAGS += -DAB_OTA_UPDATER=1
+endif
+
+LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin
+
+# Handling for EV_REL is disabled by default because some accelerometers
+# send EV_REL events.  Actual EV_REL devices are rare on modern hardware
+# so it's cleaner just to disable it by default.
+ifneq ($(BOARD_RECOVERY_NEEDS_REL_INPUT),)
+    LOCAL_CFLAGS += -DBOARD_RECOVERY_NEEDS_REL_INPUT
+endif
+
+ifeq ($(TARGET_USE_MDTP), true)
+    LOCAL_CFLAGS += -DUSE_MDTP
+endif
+
+ifeq ($(BOARD_HAS_DOWNLOAD_MODE), true)
+    LOCAL_CFLAGS += -DDOWNLOAD_MODE
+endif
+
+ifneq ($(BOARD_RECOVERY_BLDRMSG_OFFSET),)
+    LOCAL_CFLAGS += -DBOARD_RECOVERY_BLDRMSG_OFFSET=$(BOARD_RECOVERY_BLDRMSG_OFFSET)
+endif
+
+ifeq ($(TARGET_BUILD_VARIANT),user)
+    LOCAL_CFLAGS += -DRELEASE_BUILD
+endif
+
+LOCAL_CFLAGS += -DUSE_EXT4 -DMINIVOLD
+LOCAL_C_INCLUDES += system/extras/ext4_utils system/core/fs_mgr/include external/fsck_msdos
+LOCAL_C_INCLUDES += system/vold
+
+ifeq ($(TARGET_RECOVERY_UI_LIB),)
+  LOCAL_SRC_FILES += default_device.cpp
+else
+  LOCAL_STATIC_LIBRARIES += $(TARGET_RECOVERY_UI_LIB)
+endif
+
+ifeq ($(BOARD_CACHEIMAGE_PARTITION_SIZE),)
+LOCAL_REQUIRED_MODULES := recovery-persist recovery-refresh
+endif
+
+LOCAL_C_INCLUDES += system/extras/ext4_utils
+LOCAL_C_INCLUDES += external/boringssl/include
+
+ifeq ($(ONE_SHOT_MAKEFILE),)
+LOCAL_ADDITIONAL_DEPENDENCIES += \
+    fstools \
+    recovery_mkshrc \
+    bu_recovery \
+    toybox_recovery_links
+
+endif
+
+TOYBOX_INSTLIST := $(HOST_OUT_EXECUTABLES)/toybox-instlist
+
+# Set up the static symlinks
+RECOVERY_TOOLS := \
+    gunzip gzip make_ext4fs minivold reboot setup_adbd sh start stop toybox unzip vdc zip
+LOCAL_POST_INSTALL_CMD := \
+	$(hide) $(foreach t,$(RECOVERY_TOOLS),ln -sf recovery $(TARGET_RECOVERY_ROOT_OUT)/sbin/$(t);)
+
+ifneq ($(TARGET_RECOVERY_DEVICE_MODULES),)
+    LOCAL_ADDITIONAL_DEPENDENCIES += $(TARGET_RECOVERY_DEVICE_MODULES)
+endif
+
+include $(BUILD_EXECUTABLE)
+
+# Run toybox-instlist and generate the rest of the symlinks
+toybox_recovery_links: $(TOYBOX_INSTLIST)
+toybox_recovery_links: TOYBOX_BINARY := $(TARGET_RECOVERY_ROOT_OUT)/sbin/toybox
+toybox_recovery_links:
+	@echo -e ${CL_CYN}"Generate Toybox links:"${CL_RST} $$($(TOYBOX_INSTLIST))
+	@mkdir -p $(TARGET_RECOVERY_ROOT_OUT)/sbin
+	$(hide) $(TOYBOX_INSTLIST) | xargs -I'{}' ln -sf toybox '$(TARGET_RECOVERY_ROOT_OUT)/sbin/{}'
+
+# mkshrc
+include $(CLEAR_VARS)
+LOCAL_MODULE := recovery_mkshrc
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/etc
+LOCAL_SRC_FILES := etc/mkshrc
+LOCAL_MODULE_STEM := mkshrc
+include $(BUILD_PREBUILT)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := bu_recovery
+LOCAL_MODULE_STEM := bu
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := RECOVERY_EXECUTABLES
+LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+LOCAL_SRC_FILES := \
+    bu.cpp \
+    backup.cpp \
+    restore.cpp \
+    roots.cpp \
+    voldclient.cpp
+LOCAL_CFLAGS += -DMINIVOLD
+LOCAL_CFLAGS += -Wno-unused-parameter
+#ifeq ($(TARGET_USERIMAGES_USE_EXT4), true)
+    LOCAL_CFLAGS += -DUSE_EXT4
+    LOCAL_C_INCLUDES += system/extras/ext4_utils
+    LOCAL_STATIC_LIBRARIES += libext4_utils_static libz
+#endif
+LOCAL_STATIC_LIBRARIES += \
+    libsparse_static \
+    libz \
+    libmtdutils \
+    libminadbd \
+    libminui \
+    libfs_mgr \
+    libtar \
+    libcrypto_utils_static \
+    libcrypto_static \
+    libselinux \
+    libutils \
+    libcutils \
+    liblog \
+    libm \
+    libc \
+    libext2_blkid \
+    libext2_uuid
+
+LOCAL_C_INCLUDES +=         	\
+    system/core/fs_mgr/include	\
+    system/core/include     	\
+    system/core/libcutils       \
+    system/vold                 \
+    external/libtar             \
+    external/libtar/listhash    \
+    external/openssl/include    \
+    external/zlib               \
+    bionic/libc/bionic          \
+    external/e2fsprogs/lib
+
+
+include $(BUILD_EXECUTABLE)
+
+# make_ext4fs
+include $(CLEAR_VARS)
+LOCAL_MODULE := libmake_ext4fs_static
+LOCAL_MODULE_TAGS := optional
+LOCAL_CFLAGS := -Dmain=make_ext4fs_main
+LOCAL_SRC_FILES := \
+    ../../system/extras/ext4_utils/make_ext4fs_main.c \
+    ../../system/core/libcutils/canned_fs_config.c
+LOCAL_STATIC_LIBRARIES += libselinux
+include $(BUILD_STATIC_LIBRARY)
+
+# Minizip static library
+include $(CLEAR_VARS)
+LOCAL_MODULE := libminizip_static
+LOCAL_MODULE_TAGS := optional
+LOCAL_CFLAGS := -Dmain=minizip_main -D__ANDROID__ -DIOAPI_NO_64 -Wno-unknown-attributes
+LOCAL_C_INCLUDES := external/zlib
+LOCAL_SRC_FILES := \
+    ../../external/zlib/src/contrib/minizip/ioapi.c \
+    ../../external/zlib/src/contrib/minizip/minizip.c \
+    ../../external/zlib/src/contrib/minizip/zip.c
+include $(BUILD_STATIC_LIBRARY)
+
+# Miniunz static library
+include $(CLEAR_VARS)
+LOCAL_MODULE := libminiunz_static
+LOCAL_MODULE_TAGS := optional
+LOCAL_CFLAGS := -Dmain=miniunz_main -D__ANDROID__ -DIOAPI_NO_64 -Wno-unknown-attributes
+LOCAL_C_INCLUDES := external/zlib bionic/libc/include
+LOCAL_SRC_FILES := \
+    ../../external/zlib/src/contrib/minizip/ioapi.c \
+    ../../external/zlib/src/contrib/minizip/miniunz.c \
+    ../../external/zlib/src/contrib/minizip/unzip.c
+LOCAL_STATIC_LIBRARIES += libc
+include $(BUILD_STATIC_LIBRARY)
+
+# Reboot static library
+include $(CLEAR_VARS)
+LOCAL_MODULE := libreboot_static
+LOCAL_MODULE_TAGS := optional
+LOCAL_CFLAGS := -Dmain=reboot_main
+LOCAL_SRC_FILES := ../../system/core/reboot/reboot.c
+include $(BUILD_STATIC_LIBRARY)
+
+
+# recovery-persist (system partition dynamic executable run after /data mounts)
+# ===============================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := recovery-persist.cpp
+LOCAL_MODULE := recovery-persist
+LOCAL_SHARED_LIBRARIES := liblog libbase
+LOCAL_CFLAGS := -Werror
+LOCAL_INIT_RC := recovery-persist.rc
+include $(BUILD_EXECUTABLE)
+
+# recovery-refresh (system partition dynamic executable run at init)
+# ===============================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := recovery-refresh.cpp
+LOCAL_MODULE := recovery-refresh
+LOCAL_SHARED_LIBRARIES := liblog
+LOCAL_CFLAGS := -Werror
+LOCAL_INIT_RC := recovery-refresh.rc
+include $(BUILD_EXECUTABLE)
+
+# All the APIs for testing
+include $(CLEAR_VARS)
+LOCAL_CLANG := false
+LOCAL_MODULE := libverifier
+LOCAL_MODULE_TAGS := tests
+LOCAL_SRC_FILES := \
+    asn1_decoder.cpp \
+    verifier.cpp \
+    ui.cpp
+LOCAL_C_INCLUDES := system/core/fs_mgr/include
+LOCAL_STATIC_LIBRARIES := libcrypto_utils_static libcrypto_static
+include $(BUILD_STATIC_LIBRARY)
+
+include \
+    $(LOCAL_PATH)/applypatch/Android.mk \
+    $(LOCAL_PATH)/bootloader_message/Android.mk \
+    $(LOCAL_PATH)/edify/Android.mk \
+    $(LOCAL_PATH)/minui/Android.mk \
+    $(LOCAL_PATH)/minzip/Android.mk \
+    $(LOCAL_PATH)/minadbd/Android.mk \
+    $(LOCAL_PATH)/mtdutils/Android.mk \
+    $(LOCAL_PATH)/otafault/Android.mk \
+    $(LOCAL_PATH)/tests/Android.mk \
+    $(LOCAL_PATH)/tools/Android.mk \
+    $(LOCAL_PATH)/uncrypt/Android.mk \
+    $(LOCAL_PATH)/updater/Android.mk \
+    $(LOCAL_PATH)/update_verifier/Android.mk \
+    $(LOCAL_PATH)/fstools/Android.mk
+
+endif
diff --git a/minzip/SysUtil.c~ b/minzip/SysUtil.c~
new file mode 100644
index 0000000..1c6be39
--- /dev/null
+++ b/minzip/SysUtil.c~
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2006 The Android Open Source Project
+ *
+ * System utilities.
+ */
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#define LOG_TAG "sysutil"
+#include "Log.h"
+#include "SysUtil.h"
+
+static bool sysMapFD(int fd, MemMapping* pMap) {
+    assert(pMap != NULL);
+
+    struct stat sb;
+    if (fstat(fd, &sb) == -1) {
+        LOGE("fstat(%d) failed: %s\n", fd, strerror(errno));
+        return false;
+    }
+
+    void* memPtr = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (memPtr == MAP_FAILED) {
+        LOGE("mmap(%d, R, PRIVATE, %d, 0) failed: %s\n", (int) sb.st_size, fd, strerror(errno));
+        return false;
+    }
+
+    pMap->addr = memPtr;
+    pMap->length = sb.st_size;
+    pMap->range_count = 1;
+    pMap->ranges = malloc(sizeof(MappedRange));
+    if (pMap->ranges == NULL) {
+        LOGE("malloc failed: %s\n", strerror(errno));
+        munmap(memPtr, sb.st_size);
+        return false;
+    }
+    pMap->ranges[0].addr = memPtr;
+    pMap->ranges[0].length = sb.st_size;
+
+    return true;
+}
+
+static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)
+{
+    char block_dev[PATH_MAX+1];
+    size_t size;
+    unsigned int blksize;
+    size_t blocks;
+    unsigned int range_count;
+    unsigned int i;
+
+    if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {
+        LOGE("failed to read block device from header\n");
+        return -1;
+    }
+    for (i = 0; i < sizeof(block_dev); ++i) {
+        if (block_dev[i] == '\n') {
+            block_dev[i] = 0;
+            break;
+        }
+    }
+
+    if (fscanf(mapf, "%zu %u\n%u\n", &size, &blksize, &range_count) != 3) {
+        LOGE("failed to parse block map header\n");
+        return -1;
+    }
+    if (blksize != 0) {
+        blocks = ((size-1) / blksize) + 1;
+    }
+    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {
+        LOGE("invalid data in block map file: size %zu, blksize %u, range_count %u\n",
+             size, blksize, range_count);
+        return -1;
+    }
+
+    pMap->range_count = range_count;
+    pMap->ranges = calloc(range_count, sizeof(MappedRange));
+    if (pMap->ranges == NULL) {
+        LOGE("calloc(%u, %zu) failed: %s\n", range_count, sizeof(MappedRange), strerror(errno));
+        return -1;
+    }
+
+    // Reserve enough contiguous address space for the whole file.
+    unsigned char* reserve;
+    reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
+    if (reserve == MAP_FAILED) {
+        LOGE("failed to reserve address space: %s\n", strerror(errno));
+        free(pMap->ranges);
+        return -1;
+    }
+
+    int fd = open(block_dev, O_RDONLY);
+    if (fd < 0) {
+        LOGE("failed to open block device %s: %s\n", block_dev, strerror(errno));
+        //munmap(reserve, blocks * blksize);
+        free(pMap->ranges);
+        return -1;
+    }
+
+    unsigned char* next = reserve;
+    //size_t remaining_size = blocks * blksize;
+    bool success = true;
+    for (i = 0; i < range_count; ++i) {
+        size_t start, end;
+        if (fscanf(mapf, "%zu %zu\n", &start, &end) != 2) {
+            LOGE("failed to parse range %d in block map\n", i);
+            success = false;
+            break;
+        }
+        size_t length = (end - start) * blksize;
+        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {
+          LOGE("unexpected range in block map: %zu %zu\n", start, end);
+          success = false;
+          break;
+        }
+
+        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
+        if (addr == MAP_FAILED) {
+            LOGE("failed to map block %d: %s\n", i, strerror(errno));
+            success = false;
+            break;
+        }
+        pMap->ranges[i].addr = addr;
+        pMap->ranges[i].length = length;
+
+        next += length;
+        remaining_size -= length;
+    }
+    if (success && remaining_size != 0) {
+      LOGE("ranges in block map are invalid: remaining_size = %zu\n", remaining_size);
+      success = false;
+    }
+    if (!success) {
+      close(fd);
+      munmap(reserve, blocks * blksize);
+      free(pMap->ranges);
+      return -1;
+    }
+
+    close(fd);
+    pMap->addr = reserve;
+    pMap->length = size;
+
+    LOGI("mmapped %d ranges\n", range_count);
+
+    return 0;
+}
+
+int sysMapFile(const char* fn, MemMapping* pMap)
+{
+    memset(pMap, 0, sizeof(*pMap));
+
+    if (fn && fn[0] == '@') {
+        // A map of blocks
+        FILE* mapf = fopen(fn+1, "r");
+        if (mapf == NULL) {
+            LOGE("Unable to open '%s': %s\n", fn+1, strerror(errno));
+            return -1;
+        }
+
+        if (sysMapBlockFile(mapf, pMap) != 0) {
+            LOGE("Map of '%s' failed\n", fn);
+            fclose(mapf);
+            return -1;
+        }
+
+        fclose(mapf);
+    } else {
+        // This is a regular file.
+        int fd = open(fn, O_RDONLY);
+        if (fd == -1) {
+            LOGE("Unable to open '%s': %s\n", fn, strerror(errno));
+            return -1;
+        }
+
+        if (!sysMapFD(fd, pMap)) {
+            LOGE("Map of '%s' failed\n", fn);
+            close(fd);
+            return -1;
+        }
+
+        close(fd);
+    }
+    return 0;
+}
+
+/*
+ * Release a memory mapping.
+ */
+void sysReleaseMap(MemMapping* pMap)
+{
+    int i;
+    for (i = 0; i < pMap->range_count; ++i) {
+        if (munmap(pMap->ranges[i].addr, pMap->ranges[i].length) < 0) {
+            LOGE("munmap(%p, %d) failed: %s\n",
+                 pMap->ranges[i].addr, (int)pMap->ranges[i].length, strerror(errno));
+        }
+    }
+    free(pMap->ranges);
+    pMap->ranges = NULL;
+    pMap->range_count = 0;
+}
diff --git a/mtdutils/Android.mk~ b/mtdutils/Android.mk~
new file mode 100644
index 0000000..b7d35c2
--- /dev/null
+++ b/mtdutils/Android.mk~
@@ -0,0 +1,20 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	mtdutils.c \
+	mounts.c
+
+LOCAL_MODULE := libmtdutils
+LOCAL_CLANG := true
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_CLANG := true
+LOCAL_SRC_FILES := flash_image.c
+LOCAL_MODULE := flash_image
+LOCAL_MODULE_TAGS := eng
+LOCAL_STATIC_LIBRARIES := libmtdutils
+LOCAL_SHARED_LIBRARIES := libcutils liblog libc
+include $(BUILD_EXECUTABLE)
diff --git a/ui.cpp b/ui.cpp
index c3d905f..89f55ff 100644
--- a/ui.cpp
+++ b/ui.cpp
@@ -353,12 +353,12 @@ void RecoveryUI::ProcessRel(input_device* dev, int code, int value) {
         // key event.
         dev->rel_sum += value;
         if (dev->rel_sum > 3) {
-            process_key(dev, KEY_DOWN, 1);   // press down key
-            process_key(dev, KEY_DOWN, 0);   // and release it
+            ProcessKey(dev, KEY_DOWN, 1);   // press down key
+            ProcessKey(dev, KEY_DOWN, 0);   // and release it
             dev->rel_sum = 0;
         } else if (dev->rel_sum < -3) {
-            process_key(dev, KEY_UP, 1);     // press up key
-            process_key(dev, KEY_UP, 0);     // and release it
+            ProcessKey(dev, KEY_UP, 1);     // press up key
+            ProcessKey(dev, KEY_UP, 0);     // and release it
             dev->rel_sum = 0;
         }
     }
diff --git a/ui.cpp~ b/ui.cpp~
new file mode 100644
index 0000000..89f55ff
--- /dev/null
+++ b/ui.cpp~
@@ -0,0 +1,729 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/input.h>
+#include <pthread.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <cutils/properties.h>
+#include <cutils/android_reboot.h>
+#include <cutils/properties.h>
+
+#include "common.h"
+#include "roots.h"
+#include "device.h"
+#include "minui/minui.h"
+#include "screen_ui.h"
+#include "ui.h"
+
+#include "voldclient.h"
+
+#define UI_WAIT_KEY_TIMEOUT_SEC    120
+
+/* Some extra input defines */
+#ifndef ABS_MT_ANGLE
+#define ABS_MT_ANGLE 0x38
+#endif
+
+RecoveryUI::RecoveryUI()
+        : key_queue_len(0),
+          key_last_down(-1),
+          key_long_press(false),
+          key_down_count(0),
+          enable_reboot(true),
+          v_changed(0),
+          consecutive_power_keys(0),
+          last_key(-1),
+          has_power_key(false),
+          has_up_key(false),
+          has_down_key(false),
+          has_back_key(false),
+          has_home_key(false) {
+    pthread_mutex_init(&key_queue_mutex, nullptr);
+    pthread_cond_init(&key_queue_cond, nullptr);
+    memset(key_pressed, 0, sizeof(key_pressed));
+}
+
+void RecoveryUI::OnKeyDetected(int key_code) {
+    if (key_code == KEY_POWER) {
+        has_power_key = true;
+    } else if (key_code == KEY_DOWN || key_code == KEY_VOLUMEDOWN) {
+        has_down_key = true;
+    } else if (key_code == KEY_UP || key_code == KEY_VOLUMEUP) {
+        has_up_key = true;
+    } else if (key_code == KEY_BACK) {
+        has_back_key = true;
+        LOGI("Detected back key, disabling virtual back button\n");
+    } else if (key_code == KEY_HOMEPAGE || key_code == KEY_HOME) {
+        has_home_key = true;
+        LOGI("Detected home key, disabling virtual home button\n");
+    }
+}
+
+int RecoveryUI::InputCallback(int fd, uint32_t epevents, void* data) {
+    return reinterpret_cast<RecoveryUI*>(data)->OnInputEvent(fd, epevents);
+}
+
+// Reads input events, handles special hot keys, and adds to the key queue.
+static void* InputThreadLoop(void*) {
+    while (true) {
+        if (!ev_wait(-1)) {
+            ev_dispatch();
+        }
+    }
+    return nullptr;
+}
+
+void RecoveryUI::Init() {
+    calibrate_swipe();
+    ev_init(InputCallback, this);
+
+    ev_iterate_available_keys(std::bind(&RecoveryUI::OnKeyDetected, this, std::placeholders::_1));
+
+    pthread_create(&input_thread_, nullptr, InputThreadLoop, nullptr);
+}
+
+int RecoveryUI::OnInputEvent(int fd, uint32_t epevents) {
+    struct input_event ev;
+    if (ev_get_input(fd, epevents, &ev) == -1) {
+        return -1;
+    }
+
+    input_device* dev = NULL;
+    int n;
+    for (n = 0; n < MAX_NR_INPUT_DEVICES; ++n) {
+        if (input_devices[n].fd == fd) {
+            dev = &input_devices[n];
+            break;
+        }
+        if (input_devices[n].fd == -1) {
+            dev = &input_devices[n];
+            memset(dev, 0, sizeof(input_device));
+            dev->fd = fd;
+            dev->tracking_id = -1;
+            calibrate_touch(dev);
+            setup_vkeys(dev);
+            break;
+        }
+    }
+    if (!dev) {
+        LOGE("input_callback: no more available input devices\n");
+        return -1;
+    }
+
+    if (ev.type != EV_REL) {
+        dev->rel_sum = 0;
+    }
+
+    switch (ev.type) {
+    case EV_SYN:
+        ProcessSyn(dev, ev.code, ev.value);
+        break;
+    case EV_ABS:
+        ProcessAbs(dev, ev.code, ev.value);
+        break;
+    case EV_REL:
+        ProcessRel(dev, ev.code, ev.value);
+        break;
+    case EV_KEY:
+        ProcessKey(dev, ev.code, ev.value);
+        break;
+    }
+
+    return 0;
+}
+
+// Process a key-up or -down event.  A key is "registered" when it is
+// pressed and then released, with no other keypresses or releases in
+// between.  Registered keys are passed to CheckKey() to see if it
+// should trigger a visibility toggle, an immediate reboot, or be
+// queued to be processed next time the foreground thread wants a key
+// (eg, for the menu).
+//
+// We also keep track of which keys are currently down so that
+// CheckKey can call IsKeyPressed to see what other keys are held when
+// a key is registered.
+//
+// updown == 1 for key down events; 0 for key up events
+void RecoveryUI::ProcessKey(input_device* dev, int key_code, int updown) {
+    bool register_key = false;
+    bool long_press = false;
+    bool reboot_enabled;
+
+    if (key_code > KEY_MAX)
+        return;
+
+    pthread_mutex_lock(&key_queue_mutex);
+    key_pressed[key_code] = updown;
+    if (updown) {
+        ++key_down_count;
+        key_last_down = key_code;
+        key_long_press = false;
+        key_timer_t* info = new key_timer_t;
+        info->ui = this;
+        info->key_code = key_code;
+        info->count = key_down_count;
+        pthread_t thread;
+        pthread_create(&thread, nullptr, &RecoveryUI::time_key_helper, info);
+        pthread_detach(thread);
+    } else {
+        if (key_last_down == key_code) {
+            long_press = key_long_press;
+            register_key = true;
+        }
+        key_last_down = -1;
+    }
+    reboot_enabled = enable_reboot;
+    pthread_mutex_unlock(&key_queue_mutex);
+
+    if (register_key) {
+        switch (CheckKey(key_code, long_press)) {
+          case RecoveryUI::IGNORE:
+            break;
+
+          case RecoveryUI::TOGGLE:
+            ShowText(!IsTextVisible());
+            break;
+
+          case RecoveryUI::REBOOT:
+#ifndef VERIFIER_TEST
+            vdc->unmountAll();
+#endif
+            if (reboot_enabled) {
+                property_set(ANDROID_RB_PROPERTY, "reboot,");
+                while (true) { pause(); }
+            }
+            break;
+
+          case RecoveryUI::ENQUEUE:
+            EnqueueKey(key_code);
+            break;
+        }
+    }
+}
+
+void RecoveryUI::ProcessSyn(input_device* dev, int code, int value) {
+    /*
+     * Type A device release:
+     *   1. Lack of position update
+     *   2. BTN_TOUCH | ABS_PRESSURE | SYN_MT_REPORT
+     *   3. SYN_REPORT
+     *
+     * Type B device release:
+     *   1. ABS_MT_TRACKING_ID == -1 for "first" slot
+     *   2. SYN_REPORT
+     */
+
+    if (code == SYN_MT_REPORT) {
+        if (!dev->in_touch && (dev->saw_pos_x && dev->saw_pos_y)) {
+#ifdef DEBUG_TOUCH
+            LOGI("process_syn: type a press\n");
+#endif
+            handle_press(dev);
+        }
+        dev->saw_mt_report = true;
+        return;
+    }
+    if (code == SYN_REPORT) {
+        if (dev->in_touch) {
+            handle_gestures(dev);
+        }
+        else {
+            if (dev->saw_tracking_id) {
+#ifdef DEBUG_TOUCH
+            LOGI("process_syn: type b press\n");
+#endif
+                handle_press(dev);
+            }
+        }
+
+        /* Detect release */
+        if (dev->saw_mt_report) {
+            if (dev->in_touch && !dev->saw_pos_x && !dev->saw_pos_y) {
+                /* type A release */
+#ifdef DEBUG_TOUCH
+            LOGI("process_syn: type a release\n");
+#endif
+                handle_release(dev);
+                dev->slot_first = 0;
+            }
+        }
+        else {
+            if (dev->in_touch && dev->saw_tracking_id && dev->tracking_id == -1 &&
+                    dev->slot_current == dev->slot_first) {
+                /* type B release */
+#ifdef DEBUG_TOUCH
+            LOGI("process_syn: type b release\n");
+#endif
+                handle_release(dev);
+                dev->slot_first = 0;
+            }
+        }
+
+        dev->saw_pos_x = dev->saw_pos_y = false;
+        dev->saw_mt_report = dev->saw_tracking_id = false;
+    }
+}
+
+void RecoveryUI::ProcessAbs(input_device* dev, int code, int value) {
+    if (code == ABS_MT_SLOT) {
+        dev->slot_current = value;
+        if (dev->slot_first == -1) {
+            dev->slot_first = value;
+        }
+        return;
+    }
+    if (code == ABS_MT_TRACKING_ID) {
+        /*
+         * Some devices send an initial ABS_MT_SLOT event before switching
+         * to type B events, so discard any type A state related to slot.
+         */
+        dev->saw_tracking_id = true;
+        dev->slot_first = dev->slot_current = 0;
+
+        if (value != dev->tracking_id) {
+            dev->tracking_id = value;
+            if (dev->tracking_id < 0) {
+                dev->slot_nr_active--;
+            }
+            else {
+                dev->slot_nr_active++;
+            }
+        }
+        return;
+    }
+    /*
+     * For type A devices, we "lock" onto the first coordinates by ignoring
+     * position updates from the time we see a SYN_MT_REPORT until the next
+     * SYN_REPORT
+     *
+     * For type B devices, we "lock" onto the first slot seen until all slots
+     * are released
+     */
+    if (dev->slot_nr_active == 0) {
+        /* type A */
+        if (dev->saw_pos_x && dev->saw_pos_y) {
+            return;
+        }
+    }
+    else {
+        if (dev->slot_current != dev->slot_first) {
+            return;
+        }
+    }
+    if (code == ABS_MT_POSITION_X) {
+        dev->saw_pos_x = true;
+        dev->touch_pos.x = value * fb_dimensions.x / (dev->touch_max.x - dev->touch_min.x);
+    }
+    else if (code == ABS_MT_POSITION_Y) {
+        dev->saw_pos_y = true;
+        dev->touch_pos.y = value * fb_dimensions.y / (dev->touch_max.y - dev->touch_min.y);
+    }
+}
+
+void RecoveryUI::ProcessRel(input_device* dev, int code, int value) {
+#ifdef BOARD_RECOVERY_NEEDS_REL_INPUT
+    if (code == REL_Y) {
+        // accumulate the up or down motion reported by
+        // the trackball.  When it exceeds a threshold
+        // (positive or negative), fake an up/down
+        // key event.
+        dev->rel_sum += value;
+        if (dev->rel_sum > 3) {
+            ProcessKey(dev, KEY_DOWN, 1);   // press down key
+            ProcessKey(dev, KEY_DOWN, 0);   // and release it
+            dev->rel_sum = 0;
+        } else if (dev->rel_sum < -3) {
+            ProcessKey(dev, KEY_UP, 1);     // press up key
+            ProcessKey(dev, KEY_UP, 0);     // and release it
+            dev->rel_sum = 0;
+        }
+    }
+#endif
+}
+
+void* RecoveryUI::time_key_helper(void* cookie) {
+    key_timer_t* info = (key_timer_t*) cookie;
+    info->ui->time_key(info->key_code, info->count);
+    delete info;
+    return nullptr;
+}
+
+void RecoveryUI::time_key(int key_code, int count) {
+    usleep(750000);  // 750 ms == "long"
+    bool long_press = false;
+    pthread_mutex_lock(&key_queue_mutex);
+    if (key_last_down == key_code && key_down_count == count) {
+        long_press = key_long_press = true;
+    }
+    pthread_mutex_unlock(&key_queue_mutex);
+    if (long_press) KeyLongPress(key_code);
+}
+
+void RecoveryUI::calibrate_touch(input_device* dev) {
+    fb_dimensions.x = gr_fb_width();
+    fb_dimensions.y = gr_fb_height();
+
+    struct input_absinfo info;
+    memset(&info, 0, sizeof(info));
+    if (ioctl(dev->fd, EVIOCGABS(ABS_MT_POSITION_X), &info) == 0) {
+        dev->touch_min.x = info.minimum;
+        dev->touch_max.x = info.maximum;
+        dev->touch_pos.x = info.value;
+    }
+    memset(&info, 0, sizeof(info));
+    if (ioctl(dev->fd, EVIOCGABS(ABS_MT_POSITION_Y), &info) == 0) {
+        dev->touch_min.y = info.minimum;
+        dev->touch_max.y = info.maximum;
+        dev->touch_pos.y = info.value;
+    }
+#ifdef DEBUG_TOUCH
+    LOGI("calibrate_touch: fd=%d, (%d,%d)-(%d,%d) pos (%d,%d)\n", dev->fd,
+            dev->touch_min.x, dev->touch_min.y,
+            dev->touch_max.x, dev->touch_max.y,
+            dev->touch_pos.x, dev->touch_pos.y);
+#endif
+}
+
+void RecoveryUI::setup_vkeys(input_device* dev) {
+    int n;
+    char name[256];
+    char path[PATH_MAX];
+    char buf[64*MAX_NR_VKEYS];
+
+    for (n = 0; n < MAX_NR_VKEYS; ++n) {
+        dev->virtual_keys[n].keycode = -1;
+    }
+
+    memset(name, 0, sizeof(name));
+    if (ioctl(dev->fd, EVIOCGNAME(sizeof(name)), name) < 0) {
+        LOGI("setup_vkeys: no vkeys\n");
+        return;
+    }
+    sprintf(path, "/sys/board_properties/virtualkeys.%s", name);
+    int vkfd = open(path, O_RDONLY);
+    if (vkfd < 0) {
+        LOGI("setup_vkeys: could not open %s\n", path);
+        return;
+    }
+    ssize_t len = read(vkfd, buf, sizeof(buf));
+    close(vkfd);
+    if (len <= 0) {
+        LOGE("setup_vkeys: could not read %s\n", path);
+        return;
+    }
+    buf[len] = '\0';
+
+    char* p = buf;
+    char* endp;
+    for (n = 0; n < MAX_NR_VKEYS && p < buf+len && *p == '0'; ++n) {
+        int val[6];
+        int f;
+        for (f = 0; *p && f < 6; ++f) {
+            val[f] = strtol(p, &endp, 0);
+            if (p == endp)
+                break;
+            p = endp+1;
+        }
+        if (f != 6 || val[0] != 0x01)
+            break;
+        dev->virtual_keys[n].keycode = val[1];
+        dev->virtual_keys[n].min.x = val[2] - val[4]/2;
+        dev->virtual_keys[n].min.y = val[3] - val[5]/2;
+        dev->virtual_keys[n].max.x = val[2] + val[4]/2;
+        dev->virtual_keys[n].max.y = val[3] + val[5]/2;
+
+#ifdef DEBUG_TOUCH
+        LOGI("vkey: fd=%d, [%d]=(%d,%d)-(%d,%d)\n", dev->fd,
+                dev->virtual_keys[n].keycode,
+                dev->virtual_keys[n].min.x, dev->virtual_keys[n].min.y,
+                dev->virtual_keys[n].max.x, dev->virtual_keys[n].max.y);
+#endif
+    }
+}
+
+void RecoveryUI::calibrate_swipe() {
+    char strvalue[PROPERTY_VALUE_MAX];
+    int  intvalue;
+    property_get("ro.sf.lcd_density", strvalue, "160");
+    intvalue = atoi(strvalue);
+    int screen_density = (intvalue >= 160 ? intvalue : 160);
+    min_swipe_px.x = screen_density * 50 / 100; // Roughly 0.5in
+    min_swipe_px.y = screen_density * 30 / 100; // Roughly 0.3in
+#ifdef DEBUG_TOUCH
+    LOGI("calibrate_swipe: density=%d, min_swipe=(%d,%d)\n",
+            screen_density, min_swipe_px.x, min_swipe_px.y);
+#endif
+}
+
+void RecoveryUI::handle_press(input_device* dev) {
+    dev->touch_start = dev->touch_track = dev->touch_pos;
+    dev->in_touch = true;
+    dev->in_swipe = false;
+    if (dev->touch_pos.y >= gr_fb_height() - GetSysbarHeight()) {
+        SetSysbarState(1 << (3 * dev->touch_pos.x / gr_fb_width()));
+    }
+    else {
+        SetSysbarState(0);
+    }
+}
+
+void RecoveryUI::handle_release(input_device* dev) {
+    struct point diff = dev->touch_pos - dev->touch_start;
+    bool in_touch = dev->in_touch;
+    bool in_swipe = dev->in_swipe;
+
+    dev->in_touch = dev->in_swipe = false;
+
+    if (!in_swipe) {
+        int n;
+        for (n = 0; dev->virtual_keys[n].keycode != -1 && n < MAX_NR_VKEYS; ++n) {
+            vkey* vk = &dev->virtual_keys[n];
+            if (dev->touch_start.x >= vk->min.x && dev->touch_start.x < vk->max.x &&
+                    dev->touch_start.y >= vk->min.y && dev->touch_start.y < vk->max.y) {
+#ifdef DEBUG_TOUCH
+                LOGI("handle_release: vkey %d\n", vk->keycode);
+#endif
+                EnqueueKey(vk->keycode);
+                return;
+            }
+        }
+
+        int sysbar_state = GetSysbarState();
+        SetSysbarState(0);
+        if (sysbar_state == SYSBAR_BACK) {
+            ProcessKey(dev, KEY_BACK, 1);
+            ProcessKey(dev, KEY_BACK, 0);
+            return;
+        }
+        if (sysbar_state == SYSBAR_HOME) {
+            ProcessKey(dev, KEY_HOME, 1);
+            ProcessKey(dev, KEY_HOME, 0);
+            return;
+        }
+    }
+
+    if (in_swipe) {
+        if (abs(diff.x) > abs(diff.y)) {
+            if (abs(diff.x) > min_swipe_px.x) {
+                int key = (diff.x > 0 ? KEY_ENTER : KEY_BACK);
+                ProcessKey(dev, key, 1);
+                ProcessKey(dev, key, 0);
+            }
+        }
+        else {
+            /* Vertical swipe, handled realtime */
+        }
+    }
+    else {
+        int sel, start_menu_pos;
+        // Make sure touch pos is not less than menu start pos.
+        // No need to check if beyond end of menu items, since
+        // that is checked by get_menu_selection().
+        start_menu_pos = MenuItemStart();
+        if (dev->touch_pos.y >= start_menu_pos) {
+            sel = (dev->touch_pos.y - start_menu_pos)/MenuItemHeight();
+            EnqueueKey(KEY_FLAG_ABS | sel);
+        }
+    }
+}
+
+void RecoveryUI::handle_gestures(input_device* dev) {
+    struct point diff;
+    diff = dev->touch_pos - dev->touch_start;
+
+    if (abs(diff.x) > abs(diff.y)) {
+        if (abs(diff.x) > min_swipe_px.x) {
+            /* Horizontal swipe, handle it on release */
+            dev->in_swipe = true;
+        }
+    }
+    else {
+        diff.y = dev->touch_pos.y - dev->touch_track.y;
+        if (abs(diff.y) > MenuItemHeight()) {
+            dev->in_swipe = true;
+            dev->touch_track = dev->touch_pos;
+            int key = (diff.y < 0) ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;
+            ProcessKey(dev, key, 1);
+            ProcessKey(dev, key, 0);
+        }
+    }
+}
+
+void RecoveryUI::EnqueueKey(int key_code) {
+    pthread_mutex_lock(&key_queue_mutex);
+    const int queue_max = sizeof(key_queue) / sizeof(key_queue[0]);
+    if (key_queue_len < queue_max) {
+        key_queue[key_queue_len++] = key_code;
+        pthread_cond_signal(&key_queue_cond);
+    }
+    pthread_mutex_unlock(&key_queue_mutex);
+}
+
+int RecoveryUI::WaitKey() {
+    pthread_mutex_lock(&key_queue_mutex);
+    int timeouts = UI_WAIT_KEY_TIMEOUT_SEC;
+
+    // Time out after UI_WAIT_KEY_TIMEOUT_SEC, unless a USB cable is
+    // plugged in.
+    do {
+        struct timeval now;
+        struct timespec timeout;
+        gettimeofday(&now, nullptr);
+        timeout.tv_sec = now.tv_sec;
+        timeout.tv_nsec = now.tv_usec * 1000;
+        timeout.tv_sec += 1;
+
+        int rc = 0;
+        while (key_queue_len == 0 && rc != ETIMEDOUT) {
+            rc = pthread_cond_timedwait(&key_queue_cond, &key_queue_mutex, &timeout);
+            if (VolumesChanged()) {
+                pthread_mutex_unlock(&key_queue_mutex);
+                return Device::kRefresh;
+            }
+            timeouts--;
+        }
+    } while ((timeouts || IsUsbConnected()) && key_queue_len == 0);
+
+    int key = -1;
+    if (key_queue_len > 0) {
+        key = key_queue[0];
+        memcpy(&key_queue[0], &key_queue[1], sizeof(int) * --key_queue_len);
+    }
+    pthread_mutex_unlock(&key_queue_mutex);
+    return key;
+}
+
+void RecoveryUI::CancelWaitKey()
+{
+    pthread_mutex_lock(&key_queue_mutex);
+    key_queue[key_queue_len] = -2;
+    key_queue_len++;
+    pthread_cond_signal(&key_queue_cond);
+    pthread_mutex_unlock(&key_queue_mutex);
+}
+
+bool RecoveryUI::IsUsbConnected() {
+    int fd = open("/sys/class/android_usb/android0/state", O_RDONLY);
+    if (fd < 0) {
+        printf("failed to open /sys/class/android_usb/android0/state: %s\n",
+               strerror(errno));
+        return 0;
+    }
+
+    char buf;
+    // USB is connected if android_usb state is CONNECTED or CONFIGURED.
+    int connected = (TEMP_FAILURE_RETRY(read(fd, &buf, 1)) == 1) && (buf == 'C');
+    if (close(fd) < 0) {
+        printf("failed to close /sys/class/android_usb/android0/state: %s\n",
+               strerror(errno));
+    }
+    return connected;
+}
+
+bool RecoveryUI::IsKeyPressed(int key) {
+    pthread_mutex_lock(&key_queue_mutex);
+    int pressed = key_pressed[key];
+    pthread_mutex_unlock(&key_queue_mutex);
+    return pressed;
+}
+
+bool RecoveryUI::IsLongPress() {
+    pthread_mutex_lock(&key_queue_mutex);
+    bool result = key_long_press;
+    pthread_mutex_unlock(&key_queue_mutex);
+    return result;
+}
+
+bool RecoveryUI::HasThreeButtons() {
+    return has_power_key && has_up_key && has_down_key;
+}
+
+void RecoveryUI::FlushKeys() {
+    pthread_mutex_lock(&key_queue_mutex);
+    key_queue_len = 0;
+    pthread_mutex_unlock(&key_queue_mutex);
+}
+
+RecoveryUI::KeyAction RecoveryUI::CheckKey(int key, bool is_long_press) {
+    pthread_mutex_lock(&key_queue_mutex);
+    key_long_press = false;
+    pthread_mutex_unlock(&key_queue_mutex);
+
+    // If we have power and volume up keys, that chord is the signal to toggle the text display.
+    if (HasThreeButtons()) {
+        if (key == KEY_VOLUMEUP && IsKeyPressed(KEY_POWER)) {
+            return TOGGLE;
+        }
+    } else {
+        // Otherwise long press of any button toggles to the text display,
+        // and there's no way to toggle back (but that's pretty useless anyway).
+        if (is_long_press && !IsTextVisible()) {
+            return TOGGLE;
+        }
+
+        // Also, for button-limited devices, a long press is translated to KEY_ENTER.
+        if (is_long_press && IsTextVisible()) {
+            EnqueueKey(KEY_ENTER);
+            return IGNORE;
+        }
+    }
+
+    // Press power seven times in a row to reboot.
+    if (key == KEY_POWER) {
+        pthread_mutex_lock(&key_queue_mutex);
+        bool reboot_enabled = enable_reboot;
+        pthread_mutex_unlock(&key_queue_mutex);
+
+        if (reboot_enabled) {
+            ++consecutive_power_keys;
+            if (consecutive_power_keys >= 7) {
+                return REBOOT;
+            }
+        }
+    } else {
+        consecutive_power_keys = 0;
+    }
+
+    last_key = key;
+    return IsTextVisible() ? ENQUEUE : IGNORE;
+}
+
+void RecoveryUI::KeyLongPress(int) {
+}
+
+void RecoveryUI::SetEnableReboot(bool enabled) {
+    pthread_mutex_lock(&key_queue_mutex);
+    enable_reboot = enabled;
+    pthread_mutex_unlock(&key_queue_mutex);
+}
+
+bool RecoveryUI::VolumesChanged() {
+    int ret = v_changed;
+    if (v_changed > 0)
+        v_changed = 0;
+    return ret == 1;
+}
