From 6df34e9ba4a6111a5858e754a32287e430c364ec Mon Sep 17 00:00:00 2001
From: Meticulus <theonejohnnyd@gmail.com>
Date: Wed, 7 Sep 2016 08:33:00 -0500
Subject: [PATCH] 009-Add-support-for-ICS-audio-blobs

Change-Id: I6406aa8e49ba4752b38be6fcb0b51b58be2bb647
---
 services/audioflinger/AudioFlinger.cpp             | 41 ++++++++++++++++++----
 .../service/AudioPolicyInterfaceImplLegacy.cpp     | 10 ++++--
 2 files changed, 42 insertions(+), 9 deletions(-)

diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 23215dd..3353d88 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -192,7 +192,7 @@ static int load_audio_interface(const char *if_name, audio_hw_device_t **dev)
     return 0;
 
 out:
-    *dev = NULL;
+    //*dev = NULL;
     return rc;
 }
 
@@ -892,7 +892,7 @@ status_t AudioFlinger::setMasterMute(bool muted)
 
     Mutex::Autolock _l(mLock);
     mMasterMute = muted;
-
+#ifndef ICS_AUDIO_BLOB
     // Set master mute in the HALs which support it.
     for (size_t i = 0; i < mAudioHwDevs.size(); i++) {
         AutoMutex lock(mHardwareLock);
@@ -915,7 +915,7 @@ status_t AudioFlinger::setMasterMute(bool muted)
         }
         mPlaybackThreads.valueAt(i)->setMasterMute(muted);
     }
-
+#endif
     return NO_ERROR;
 }
 
@@ -1229,7 +1229,12 @@ size_t AudioFlinger::getInputBufferSize(uint32_t sampleRate, audio_format_t form
         // Note: config is currently a const parameter for get_input_buffer_size()
         // but we use a copy from proposed in case config changes from the call.
         config = proposed;
+#ifndef ICS_AUDIO_BLOB
         frames = dev->get_input_buffer_size(dev, &config);
+#else
+    	frames = dev->get_input_buffer_size(dev, sampleRate, format, popcount(channelMask));
+#endif
+
         if (frames != 0) {
             break; // hal success, config is the result
         }
@@ -1654,7 +1659,7 @@ audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)
     AudioHwDevice::Flags flags = static_cast<AudioHwDevice::Flags>(0);
     {  // scope for auto-lock pattern
         AutoMutex lock(mHardwareLock);
-
+#if !defined(ICS_AUDIO_BLOB) && !defined(MR0_AUDIO_BLOB)
         if (0 == mAudioHwDevs.size()) {
             mHardwareStatus = AUDIO_HW_GET_MASTER_VOLUME;
             if (NULL != dev->get_master_volume) {
@@ -1672,21 +1677,21 @@ audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)
                 }
             }
         }
-
+#endif
         mHardwareStatus = AUDIO_HW_SET_MASTER_VOLUME;
         if ((NULL != dev->set_master_volume) &&
             (OK == dev->set_master_volume(dev, mMasterVolume))) {
             flags = static_cast<AudioHwDevice::Flags>(flags |
                     AudioHwDevice::AHWD_CAN_SET_MASTER_VOLUME);
         }
-
+#if !defined(ICS_AUDIO_BLOB) && !defined(MR0_AUDIO_BLOB)
         mHardwareStatus = AUDIO_HW_SET_MASTER_MUTE;
         if ((NULL != dev->set_master_mute) &&
             (OK == dev->set_master_mute(dev, mMasterMute))) {
             flags = static_cast<AudioHwDevice::Flags>(flags |
                     AudioHwDevice::AHWD_CAN_SET_MASTER_MUTE);
         }
-
+#endif
         mHardwareStatus = AUDIO_HW_IDLE;
     }
 
@@ -1929,7 +1934,12 @@ status_t AudioFlinger::openOutput(audio_module_handle_t module,
         thread->ioConfigChanged(AUDIO_OUTPUT_OPENED);
 
         // the first primary output opened designates the primary hw device
+#ifdef STE_HARDWARE
+        if ( mPrimaryHardwareDev == NULL ) {
+#else
         if ((mPrimaryHardwareDev == NULL) && (flags & AUDIO_OUTPUT_FLAG_PRIMARY)) {
+#endif
+
             ALOGI("Using module %d has the primary audio interface", module);
             mPrimaryHardwareDev = thread->getOutput()->audioHwDev;
 
@@ -2118,8 +2128,17 @@ sp<AudioFlinger::RecordThread> AudioFlinger::openInput_l(audio_module_handle_t m
     audio_config_t halconfig = *config;
     audio_hw_device_t *inHwHal = inHwDev->hwDevice();
     audio_stream_in_t *inStream = NULL;
+#ifndef ICS_AUDIO_BLOB
     status_t status = inHwHal->open_input_stream(inHwHal, *input, devices, &halconfig,
                                         &inStream, flags, address.string(), source);
+#else
+    status_t status = inHwHal->open_input_stream(inHwHal, device, 
+                                        (int *)&config.format, 
+                                        &config.channel_mask,
+                                        &config.sample_rate, (audio_in_acoustics_t)0,
+                                        &inStream);
+#endif
+
     ALOGV("openInput_l() openInputStream returned input %p, SamplingRate %d"
            ", Format %#x, Channels %x, flags %#x, status %d addr %s",
             inStream,
@@ -2140,8 +2159,16 @@ sp<AudioFlinger::RecordThread> AudioFlinger::openInput_l(audio_module_handle_t m
         // FIXME describe the change proposed by HAL (save old values so we can log them here)
         ALOGV("openInput_l() reopening with proposed sampling rate and channel mask");
         inStream = NULL;
+#ifndef ICS_AUDIO_BLOB
         status = inHwHal->open_input_stream(inHwHal, *input, devices, &halconfig,
                                             &inStream, flags, address.string(), source);
+#else
+        status = inHwHal->open_input_stream(inHwHal, device, 
+                                        (int *)&config.format, 
+                                        &config.channel_mask,
+                                        &config.sample_rate, (audio_in_acoustics_t)0,
+                                        &inStream);
+#endif
         // FIXME log this new status; HAL should not propose any further changes
     }
 
diff --git a/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp b/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp
index da7f45d..b5aba2b 100644
--- a/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp
+++ b/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp
@@ -382,12 +382,15 @@ status_t AudioPolicyService::setStreamVolumeIndex(audio_stream_type_t stream,
         return BAD_VALUE;
     }
     Mutex::Autolock _l(mLock);
+#ifndef ICS_AUDIO_BLOB
     if (mpAudioPolicy->set_stream_volume_index_for_device) {
         return mpAudioPolicy->set_stream_volume_index_for_device(mpAudioPolicy,
                                                                 stream,
                                                                 index,
                                                                 device);
-    } else {
+    } else 
+#endif
+    {
         return mpAudioPolicy->set_stream_volume_index(mpAudioPolicy, stream, index);
     }
 }
@@ -403,12 +406,15 @@ status_t AudioPolicyService::getStreamVolumeIndex(audio_stream_type_t stream,
         return BAD_VALUE;
     }
     Mutex::Autolock _l(mLock);
+#ifndef ICS_AUDIO_BLOB
     if (mpAudioPolicy->get_stream_volume_index_for_device) {
         return mpAudioPolicy->get_stream_volume_index_for_device(mpAudioPolicy,
                                                                 stream,
                                                                 index,
                                                                 device);
-    } else {
+    } else 
+#endif
+    {
         return mpAudioPolicy->get_stream_volume_index(mpAudioPolicy, stream, index);
     }
 }
-- 
1.9.1

