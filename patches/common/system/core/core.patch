From e98a4d426e160f1bbeb4ac1957304aa27e0b4490 Mon Sep 17 00:00:00 2001
From: Meticulus <theonejohnnyd@gmail.com>
Date: Sun, 11 Sep 2016 06:27:07 -0500
Subject: [PATCH] core

Change-Id: Ie8f6913ab0f7ffeaafb51ea6f7f5f91ed9261c2b
---
 include/utils/Flattenable.h | 22 ++++++++++++++++++++++
 include/utils/VectorImpl.h  | 24 ++++++++++++++++++++++++
 init/Android.mk             |  1 -
 init/init.cpp               | 17 ++++++++++-------
 libutils/Android.mk         |  6 ++++++
 libutils/Flattenable.cpp    | 24 ++++++++++++++++++++++++
 libutils/Threads.cpp        |  9 +++++++++
 libutils/VectorImpl.cpp     | 22 ++++++++++++++++++++++
 8 files changed, 117 insertions(+), 8 deletions(-)
 create mode 100644 libutils/Flattenable.cpp

diff --git a/include/utils/Flattenable.h b/include/utils/Flattenable.h
index 882a8b2..495b90d 100644
--- a/include/utils/Flattenable.h
+++ b/include/utils/Flattenable.h
@@ -79,21 +79,35 @@ public:
  * Flattenable objects must implement this protocol.
  */
 
+#ifndef STE_HARDWARE
 template <typename T>
+#endif
 class Flattenable {
 public:
     // size in bytes of the flattened object
+#ifdef STE_HARDWARE
+    virtual size_t getFlattenedSize() const = 0;
+#else
     inline size_t getFlattenedSize() const;
+#endif
 
     // number of file descriptors to flatten
+#ifdef STE_HARDWARE
+    virtual size_t getFdCount() const = 0;
+#else
     inline size_t getFdCount() const;
+#endif
 
     // flattens the object into buffer.
     // size should be at least of getFlattenedSize()
     // file descriptors are written in the fds[] array but ownership is
     // not transfered (ie: they must be dupped by the caller of
     // flatten() if needed).
+#ifdef STE_HARDWARE
+    virtual status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const = 0;
+#else
     inline status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const;
+#endif
 
     // unflattens the object from buffer.
     // size should be equal to the value of getFlattenedSize() when the
@@ -102,6 +116,13 @@ public:
     // don't need to be dupped(). ie: the caller of unflatten doesn't
     // keep ownership. If a fd is not retained by unflatten() it must be
     // explicitly closed.
+#ifdef STE_HARDWARE
+    virtual status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count) = 0;
+
+protected:
+    virtual ~Flattenable() = 0;
+};
+#else
     inline status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count);
 };
 
@@ -123,6 +144,7 @@ inline status_t Flattenable<T>::unflatten(
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
     return static_cast<T*>(this)->T::unflatten(buffer, size, fds, count);
 }
+#endif
 
 /*
  * LightFlattenable is a protocol allowing object to serialize themselves out
diff --git a/include/utils/VectorImpl.h b/include/utils/VectorImpl.h
index 21ad71c..8adf8fa 100644
--- a/include/utils/VectorImpl.h
+++ b/include/utils/VectorImpl.h
@@ -124,6 +124,18 @@ private:
 
     const   uint32_t    mFlags;
     const   size_t      mItemSize;
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedVectorImpl1();
+    virtual void            reservedVectorImpl2();
+    virtual void            reservedVectorImpl3();
+    virtual void            reservedVectorImpl4();
+    virtual void            reservedVectorImpl5();
+    virtual void            reservedVectorImpl6();
+    virtual void            reservedVectorImpl7();
+    virtual void            reservedVectorImpl8();
+#endif
+
 };
 
 
@@ -155,6 +167,18 @@ public:
         
 protected:
     virtual int             do_compare(const void* lhs, const void* rhs) const = 0;
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedSortedVectorImpl1();
+    virtual void            reservedSortedVectorImpl2();
+    virtual void            reservedSortedVectorImpl3();
+    virtual void            reservedSortedVectorImpl4();
+    virtual void            reservedSortedVectorImpl5();
+    virtual void            reservedSortedVectorImpl6();
+    virtual void            reservedSortedVectorImpl7();
+    virtual void            reservedSortedVectorImpl8();
+#endif
+
 
 private:
             ssize_t         _indexOrderOf(const void* item, size_t* order = 0) const;
diff --git a/init/Android.mk b/init/Android.mk
index 85dfbfc..7afe762 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -16,7 +16,6 @@ init_cflags += \
     $(init_options) \
     -Wall -Wextra \
     -Wno-unused-parameter \
-    -Werror \
 
 init_clang := true
 
diff --git a/init/init.cpp b/init/init.cpp
index 58d7d34..402c2c5 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -817,7 +817,7 @@ static void export_kernel_boot_props() {
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+        { "ro.boot.hardware",   "ro.hardware",   "samsungcodina", },
 #ifndef IGNORE_RO_BOOT_REVISION
         { "ro.boot.revision",   "ro.revision",   "0", },
 #endif
@@ -873,6 +873,7 @@ static void process_kernel_cmdline(void)
     import_kernel_cmdline(false, import_kernel_nv);
     if (qemu[0])
         import_kernel_cmdline(true, import_kernel_nv);
+    property_set("ro.boot.hardware","samsungcodina");
 }
 
 static int queue_property_triggers_action(int nargs, char **args)
@@ -915,7 +916,8 @@ static selinux_enforcing_status selinux_status_from_cmdline() {
 
 static bool selinux_is_disabled(void)
 {
-    if (ALLOW_DISABLE_SELINUX) {
+    return true;
+    /*if (ALLOW_DISABLE_SELINUX) {
         if (access("/sys/fs/selinux", F_OK) != 0) {
             // SELinux is not compiled into the kernel, or has been disabled
             // via the kernel command line "selinux=0".
@@ -924,15 +926,16 @@ static bool selinux_is_disabled(void)
         return selinux_status_from_cmdline() == SELINUX_DISABLED;
     }
 
-    return false;
+    return true;*/
 }
 
 static bool selinux_is_enforcing(void)
 {
-    if (ALLOW_DISABLE_SELINUX) {
+    return false;
+    /*if (ALLOW_DISABLE_SELINUX) {
         return selinux_status_from_cmdline() == SELINUX_ENFORCING;
     }
-    return true;
+    return false;*/
 }
 
 int selinux_reload_policy(void)
@@ -964,8 +967,8 @@ static int audit_callback(void *data, security_class_t /*cls*/, char *buf, size_
 
 static void security_failure() {
     ERROR("Security failure; rebooting into recovery mode...\n");
-    android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
-    while (true) { pause(); }  // never reached
+    //android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+    //while (true) { pause(); }  // never reached
 }
 
 static void selinux_initialize(bool in_kernel_domain) {
diff --git a/libutils/Android.mk b/libutils/Android.mk
index 23a5c59..81bd733 100644
--- a/libutils/Android.mk
+++ b/libutils/Android.mk
@@ -39,6 +39,12 @@ commonSources:= \
 	VectorImpl.cpp \
 	misc.cpp \
 
+
+ifeq ($(BOARD_USES_STE_HARDWARE),true)
+	commonSources += Flattenable.cpp
+endif
+
+
 host_commonCflags := -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS) -Werror
 
 ifeq ($(HOST_OS),windows)
diff --git a/libutils/Flattenable.cpp b/libutils/Flattenable.cpp
new file mode 100644
index 0000000..1f2ffaa
--- /dev/null
+++ b/libutils/Flattenable.cpp
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <utils/Flattenable.h>
+
+namespace android {
+
+Flattenable::~Flattenable() {
+}
+
+}; // namespace android
diff --git a/libutils/Threads.cpp b/libutils/Threads.cpp
index 1e014c6..9f37ddf 100644
--- a/libutils/Threads.cpp
+++ b/libutils/Threads.cpp
@@ -301,6 +301,15 @@ void androidSetCreateThreadFunc(android_create_thread_fn func)
     gCreateThreadFn = func;
 }
 
+extern "C" pid_t androidGetTid()
+{
+#ifdef HAVE_GETTID
+    return gettid();
+#else
+    return getpid();
+#endif
+}
+
 #ifdef HAVE_ANDROID_OS
 int androidSetThreadPriority(pid_t tid, int pri)
 {
diff --git a/libutils/VectorImpl.cpp b/libutils/VectorImpl.cpp
index de65a6c..c321c6c 100644
--- a/libutils/VectorImpl.cpp
+++ b/libutils/VectorImpl.cpp
@@ -554,6 +554,17 @@ void VectorImpl::_do_move_backward(void* dest, const void* from, size_t num) con
 
 /*****************************************************************************/
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void VectorImpl::reservedVectorImpl1() { } 
+void VectorImpl::reservedVectorImpl2() { } 
+void VectorImpl::reservedVectorImpl3() { } 
+void VectorImpl::reservedVectorImpl4() { } 
+void VectorImpl::reservedVectorImpl5() { } 
+void VectorImpl::reservedVectorImpl6() { } 
+void VectorImpl::reservedVectorImpl7() { } 
+void VectorImpl::reservedVectorImpl8() { } 
+#endif
+
 SortedVectorImpl::SortedVectorImpl(size_t itemSize, uint32_t flags)
     : VectorImpl(itemSize, flags)
 {
@@ -667,6 +678,17 @@ ssize_t SortedVectorImpl::remove(const void* item)
     return i;
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void SortedVectorImpl::reservedSortedVectorImpl1() { };
+void SortedVectorImpl::reservedSortedVectorImpl2() { };
+void SortedVectorImpl::reservedSortedVectorImpl3() { };
+void SortedVectorImpl::reservedSortedVectorImpl4() { };
+void SortedVectorImpl::reservedSortedVectorImpl5() { };
+void SortedVectorImpl::reservedSortedVectorImpl6() { };
+void SortedVectorImpl::reservedSortedVectorImpl7() { };
+void SortedVectorImpl::reservedSortedVectorImpl8() { };
+#endif
+
 /*****************************************************************************/
 
 }; // namespace android
-- 
1.9.1

