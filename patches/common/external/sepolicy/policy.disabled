From 78d5b3de071a9ccf82e892a322e3c84085106e7d Mon Sep 17 00:00:00 2001
From: Meticulus <theonejohnnyd@gmail.com>
Date: Tue, 5 Jul 2016 08:41:32 -0500
Subject: [PATCH] policy

Change-Id: I81c730dd0cfad4130937bf1f165752caaa5a2545
---
 admsrv.te     | 31 +++++++++++++++++++++++++++++++
 app.te        |  8 ++++----
 device.te     |  2 ++
 domain.te     | 19 ++++++++++---------
 init.te       |  2 +-
 lvm.te        | 24 ++++++++++++++++++++++++
 netd.te       |  2 +-
 nvcpud.te     | 11 +++++++++++
 service.te    |  1 +
 su.te         |  1 +
 system_app.te |  8 ++++++++
 11 files changed, 94 insertions(+), 15 deletions(-)
 create mode 100644 admsrv.te
 create mode 100644 lvm.te
 create mode 100644 nvcpud.te

diff --git a/admsrv.te b/admsrv.te
new file mode 100644
index 0000000..515456a
--- /dev/null
+++ b/admsrv.te
@@ -0,0 +1,31 @@
+# STE admsrv
+#
+type admsrv, domain;
+type admsrv_exec, exec_type, file_type;
+
+init_daemon_domain(admsrv)
+
+allow admsrv self:capability sys_nice;
+allow admsrv self:capability chown;
+allow admsrv self:capability dac_override;
+allow admsrv self:capability fowner;
+allow admsrv shell_data_file:dir { read search setattr add_name remove_name write };
+allow admsrv shell_data_file:sock_file { create getattr setattr open read write unlink };
+allow admsrv shell_data_file:file { open getattr setattr read write unlink create lock };
+allow admsrv sysfs_wake_lock: file { open read write };
+allow admsrv sysfs_devices_system_cpu:file { write };
+allow admsrv system_file:file { entrypoint execute_no_trans };
+allow admsrv admsrv:process { execmem };
+allow admsrv shell_exec:file { execute open read execute_no_trans };
+allow admsrv system_data_file:dir { open read write create remove_name add_name getattr setattr };
+allow admsrv system_data_file:file { create open rename read write link unlink lock setattr };
+allow admsrv device:file { open read write };
+allow admsrv device:chr_file { open read write ioctl };
+allow admsrv audio_device:dir { search };
+allow admsrv audio_device:chr_file { open getattr read write ioctl };
+allow admsrv unlabeled:file { setattr };
+allow admsrv radio_device:chr_file { open getattr read write ioctl };
+allow admsrv admsrv:netlink_socket { create bind setopt read write };
+allow admsrv tmpfs:dir { open read write add_name remove_name };
+allow admsrv admsrv_tmpfs:file { open read write create unlink };
+allow admsrv admsrv:fd { use };
diff --git a/app.te b/app.te
index 423be14..86e410f 100644
--- a/app.te
+++ b/app.te
@@ -219,7 +219,7 @@ neverallow appdomain {
 }:chr_file { read write };
 
 # Note: Try expanding list of app domains in the future.
-neverallow { untrusted_app isolated_app shell } graphics_device:chr_file { read write };
+#neverallow { untrusted_app isolated_app shell } graphics_device:chr_file { read write };
 
 neverallow { appdomain -nfc } nfc_device:chr_file
     { read write };
@@ -283,7 +283,7 @@ neverallow appdomain system_file:dir_file_class_set
     { create write setattr relabelfrom relabelto append unlink link rename };
 
 # Write to entrypoint executables.
-neverallow appdomain exec_type:file
+neverallow { appdomain -system_app } exec_type:file
     { create write setattr relabelfrom relabelto append unlink link rename };
 
 # Write to system-owned parts of /data.
@@ -337,9 +337,9 @@ neverallow appdomain efs_file:dir_file_class_set write;
 neverallow { appdomain -shell } efs_file:dir_file_class_set read;
 
 # Write to various pseudo file systems.
-neverallow { appdomain -bluetooth -nfc }
+neverallow { appdomain -bluetooth -nfc -system_app }
     sysfs:dir_file_class_set write;
-neverallow appdomain
+neverallow { appdomain -bluetooth -system_app }
     proc:dir_file_class_set write;
 
 # Access to syslog(2) or /proc/kmsg.
diff --git a/device.te b/device.te
index 7dd935b..6ff6ac6 100644
--- a/device.te
+++ b/device.te
@@ -68,6 +68,8 @@ type root_block_device, dev_type;
 # factory reset protection block device
 type frp_block_device, dev_type;
 
+type nvcpu_device, dev_type;
+
 # Userdata block device mounted on /data.
 type userdata_block_device, dev_type;
 
diff --git a/domain.te b/domain.te
index bfb5f05..f5dc8bb 100644
--- a/domain.te
+++ b/domain.te
@@ -178,7 +178,7 @@ neverallow { domain -unconfineddomain -recovery } unlabeled:dir_file_class_set c
 neverallow { domain -debuggerd -vold -dumpstate -system_server } self:capability sys_ptrace;
 
 # Limit device node creation to these whitelisted domains.
-neverallow { domain -kernel -init -recovery -ueventd -watchdogd -healthd -vold -uncrypt } self:capability mknod;
+neverallow { domain -kernel -init -recovery -ueventd -watchdogd -healthd -vold -lvm -uncrypt } self:capability mknod;
 
 attribute rmt_placeholder;
 # Limit raw I/O to these whitelisted domains.
@@ -235,11 +235,11 @@ neverallow { domain -init } kernel:security setsecparam;
 neverallow { domain -init -system_server -ueventd -unconfineddomain } hw_random_device:chr_file *;
 
 # Ensure that all entrypoint executables are in exec_type.
-neverallow domain { file_type -exec_type }:file entrypoint;
+#neverallow domain { file_type -exec_type }:file entrypoint;
 
 # Ensure that nothing in userspace can access /dev/mem or /dev/kmem
-neverallow { domain -rmt_placeholder -kernel -ueventd -init } kmem_device:chr_file *;
-neverallow { domain -rmt_placeholder } kmem_device:chr_file ~{ create relabelto unlink setattr };
+neverallow { domain -rmt_placeholder -kernel -ueventd -init -lvm } kmem_device:chr_file *;
+neverallow { domain -rmt_placeholder -lvm } kmem_device:chr_file ~{ create relabelto unlink setattr };
 
 # Only init should be able to configure kernel usermodehelpers or
 # security-sensitive proc settings.
@@ -255,17 +255,18 @@ neverallow domain init:binder call;
 
 # Don't allow raw read/write/open access to block_device
 # Rather force a relabel to a more specific type
-neverallow { domain -kernel -init -recovery -vold -uncrypt -install_recovery } block_device:blk_file { open read write };
+neverallow { domain -kernel -init -recovery -vold -uncrypt -install_recovery -sysinit -lvm } block_device:blk_file { open read write };
 
 # Don't allow raw read/write/open access to generic devices.
 # Rather force a relabel to a more specific type.
 # ueventd is exempt from this, as its managing these devices.
-neverallow { domain -unconfineddomain -ueventd -recovery } device:chr_file { open read write };
+neverallow { domain -unconfineddomain -ueventd -recovery  -mediaserver -system_server -wpa -bluetooth -nvcpud -lvm -admsrv } device:chr_file { open read write };
 
 # Limit what domains can mount filesystems or change their mount flags.
 # sdcard_type / vfat is exempt as a larger set of domains need
 # this capability, including device-specific domains.
-neverallow { domain -kernel -init -recovery -vold -zygote } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };
+
+neverallow { domain -kernel -init -recovery -vold -zygote -sysinit } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };
 
 #
 # Assert that, to the extent possible, we're not loading executable content from
@@ -291,11 +292,11 @@ neverallow { domain -init -recovery } property_data_file:dir { create setattr re
 neverallow { domain -init -recovery } property_data_file:file { create setattr relabelfrom write append unlink link rename };
 
 # Only recovery should be doing writes to /system
-neverallow { domain -recovery } { system_file exec_type }:dir_file_class_set
+neverallow { domain -recovery -system_app } { system_file exec_type }:dir_file_class_set
     { create write setattr relabelfrom relabelto append unlink link rename };
 
 # Nothing should be writing to files in the rootfs.
-neverallow { domain -recovery } rootfs:file { create write setattr relabelto append unlink link rename };
+neverallow { domain -recovery -vold -init -lvm } rootfs:file { create write setattr relabelto append unlink link rename };
 
 # Restrict context mounts to specific types marked with
 # the contextmount_type attribute.
diff --git a/init.te b/init.te
index 5275f4f..101aa94 100644
--- a/init.te
+++ b/init.te
@@ -120,4 +120,4 @@ allow init app_data_file:{ lnk_file dir } { getattr relabelfrom };
 # never via an exec-based transition.
 neverallow { domain -kernel} init:process dyntransition;
 neverallow domain init:process transition;
-neverallow init { file_type fs_type }:file entrypoint;
+#neverallow init { file_type fs_type }:file entrypoint;
diff --git a/lvm.te b/lvm.te
new file mode 100644
index 0000000..612d13d
--- /dev/null
+++ b/lvm.te
@@ -0,0 +1,24 @@
+# lvm
+# requires patch for some "neverallows" in external/sepolicy.
+type lvm, domain;
+type lvm_exec, exec_type, file_type;
+
+allow lvm rootfs:file { create unlink link rename append execute_no_trans };
+allow lvm rootfs:dir { write add_name create remove_name };
+allow lvm kmem_device:chr_file { getattr } ;
+allow lvm init:dir { search write };
+allow lvm init:file { open read };
+allow lvm self:capability dac_override;
+allow lvm self:capability mknod;
+allow lvm self:capability sys_admin;
+allow lvm self:capability sys_nice;
+allow lvm self:capability ipc_lock;
+allow lvm device:dir { getattr create read write open add_name };
+allow lvm device:chr_file { getattr create open read write ioctl };
+allow lvm device:lnk_file { create };
+allow lvm device:blk_file { create getattr setattr ioctl open read write };
+allow lvm block_device:dir { getattr search open read write add_name };
+allow lvm block_device:blk_file { create getattr setattr ioctl open read write };
+allow lvm dm_device:chr_file { getattr open read write };
+allow lvm devpts:dir { read open };
+allow lvm sysfs:file { open read write };
diff --git a/netd.te b/netd.te
index b27628c..c30577c 100644
--- a/netd.te
+++ b/netd.te
@@ -87,4 +87,4 @@ neverallow netd { domain }:process ptrace;
 neverallow netd system_file:dir_file_class_set write;
 
 # Write to files in /data/data or system files on /data
-neverallow netd { app_data_file system_data_file }:dir_file_class_set write;
+#neverallow netd { app_data_file system_data_file }:dir_file_class_set write;
diff --git a/nvcpud.te b/nvcpud.te
new file mode 100644
index 0000000..d086731
--- /dev/null
+++ b/nvcpud.te
@@ -0,0 +1,11 @@
+type nvcpud, domain;
+type nvcpud_exec, exec_type, file_type;
+init_daemon_domain(nvcpud)
+
+binder_use(nvcpud)
+binder_service(nvcpud)
+binder_call(nvcpud, system_server)
+
+allow nvcpud nvcpu_service:service_manager add;
+allow nvcpud nvcpu_device:chr_file { open read write };
+allow nvcpud device:chr_file { open read write };
diff --git a/service.te b/service.te
index 33e2c99..3446a5f 100644
--- a/service.te
+++ b/service.te
@@ -11,3 +11,4 @@ type radio_service,             service_manager_type;
 type surfaceflinger_service,    service_manager_type;
 type system_app_service,        service_manager_type;
 type system_server_service,     service_manager_type;
+type nvcpu_service,		service_manager_type;
diff --git a/su.te b/su.te
index 73ca514..5fbb404 100644
--- a/su.te
+++ b/su.te
@@ -7,6 +7,7 @@ userdebug_or_eng(`
   # wrapped to ensure that it does not exist at all on -user builds.
   type su, domain;
   domain_auto_trans(shell, su_exec, su)
+  domain_auto_trans(system_app, su_exec, su)
 
   # Allow dumpstate to call su on userdebug / eng builds to collect
   # additional information.
diff --git a/system_app.te b/system_app.te
index 0930ca0..8948bc7 100644
--- a/system_app.te
+++ b/system_app.te
@@ -8,6 +8,14 @@ app_domain(system_app)
 net_domain(system_app)
 binder_service(system_app)
 
+allow system_app sysfs_devices_system_iosched:file { open read write getattr };
+allow system_app sysfs_lowmemorykiller:file { open read write getattr};
+allow system_app sysfs:file { open read write getattr};
+allow system_app sysfs_devices_system_cpu:file { open read write getattr };
+allow system_app proc_dirty_ratio:file { open read write getattr };
+allow system_app proc:file { open read write getattr };
+allow system_app system_app_data_file:file { open read execute execute_no_trans};
+
 # Read and write /data/data subdirectory.
 allow system_app system_app_data_file:dir create_dir_perms;
 allow system_app system_app_data_file:file create_file_perms;
-- 
1.9.1

