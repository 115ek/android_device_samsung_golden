From 3205a005c929f259b2a4b332069fd2839b07e7d4 Mon Sep 17 00:00:00 2001
From: Meticulus <theonejohnnyd@gmail.com>
Date: Tue, 6 Sep 2016 18:48:52 -0500
Subject: [PATCH] 0001-Reenable-support-for-non-PIE-executables

Change-Id: Ia3661e6fed377dbe749dc7bd4acaff290aa15f3a
---
 linker/linker.cpp | 140 ++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 105 insertions(+), 35 deletions(-)

diff --git a/linker/linker.cpp b/linker/linker.cpp
index 364ecd5..8056087 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -1925,10 +1925,10 @@ bool soinfo::relocate(const VersionTracker& version_tracker, ElfRelIteratorT&& r
 
     const ElfW(Sym)* s = nullptr;
     soinfo* lsi = nullptr;
+    const version_info* vi = nullptr;
 
     if (sym != 0) {
       sym_name = get_string(symtab_[sym].st_name);
-      const version_info* vi = nullptr;
 
       if (!lookup_version_info(version_tracker, sym, sym_name, &vi)) {
         return false;
@@ -2176,18 +2176,55 @@ bool soinfo::relocate(const VersionTracker& version_tracker, ElfRelIteratorT&& r
         }
         break;
 
-      case R_AARCH64_COPY:
-        /*
-         * ET_EXEC is not supported so this should not happen.
-         *
-         * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0056b/IHI0056B_aaelf64.pdf
-         *
-         * Section 4.6.11 "Dynamic relocations"
-         * R_AARCH64_COPY may only appear in executable objects where e_type is
-         * set to ET_EXEC.
-         */
-        DL_ERR("%s R_AARCH64_COPY relocations are not supported", get_realpath());
-        return false;
+      case R_AARCH64_COPY: 
+     if ((flags_ & FLAG_EXE) == 0) {
+         /*
+           * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
+           *
+           * Section 4.7.1.10 "Dynamic relocations"
+           * R_AARCH64_COPY may only appear in executable objects where e_type is
+           * set to ET_EXEC.
+           *
+           * FLAG_EXE is set for both ET_DYN and ET_EXEC executables.
+           * We should explicitly disallow ET_DYN executables from having
+           * R_AARCH64_COPY relocations.
+           */
+         //DL_ERR("%s R_AARCH64_COPY relocations only supported for ET_EXEC", name);
+         return false;
+     }
+     count_relocation(kRelocCopy);
+     MARK(rela->r_offset);
+     TRACE_TYPE(RELO, "RELO COPY %16llx <- %lld @ %16llx %s\n",
+                reloc,
+                s->st_size,
+                (sym_addr + rela->r_addend),
+                sym_name);
+     if (reloc == (sym_addr + rela->r_addend)) {
+         const ElfW(Sym)* src;
+	 if(!soinfo_do_lookup(this, sym_name, vi, &lsi, global_group, local_group, &src))
+		return false;
+
+         if (src == NULL) {
+             //DL_ERR("%s R_AARCH64_COPY relocation source cannot be resolved", name);
+             return false;
+         }
+         if (lsi->has_DT_SYMBOLIC) {
+             //DL_ERR("%s invalid R_AARCH64_COPY relocation against DT_SYMBOLIC shared "
+              //      "library %s (built with -Bsymbolic?)", name, lsi->name);
+             return false;
+         }
+         if (s->st_size < src->st_size) {
+             DL_ERR("%s R_AARCH64_COPY relocation size mismatch (%lld < %lld)",
+                    name, s->st_size, src->st_size);
+             return false;
+         }
+         memcpy(reinterpret_cast<void*>(reloc),
+                reinterpret_cast<void*>(src->st_value + lsi->load_bias), src->st_size);
+     } else {
+         //DL_ERR("%s R_AARCH64_COPY relocation target cannot be resolved", name);
+         return false;
+     }
+     break; 
       case R_AARCH64_TLS_TPREL64:
         TRACE_TYPE(RELO, "RELO TLS_TPREL64 *** %16llx <- %16llx - %16llx\n",
                    reloc, (sym_addr + addend), rel->r_offset);
@@ -2234,17 +2271,50 @@ bool soinfo::relocate(const VersionTracker& version_tracker, ElfRelIteratorT&& r
         *reinterpret_cast<ElfW(Addr)*>(reloc) += sym_addr - rel->r_offset;
         break;
       case R_ARM_COPY:
-        /*
-         * ET_EXEC is not supported so this should not happen.
-         *
-         * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
-         *
-         * Section 4.6.1.10 "Dynamic relocations"
-         * R_ARM_COPY may only appear in executable objects where e_type is
-         * set to ET_EXEC.
-         */
-        DL_ERR("%s R_ARM_COPY relocations are not supported", get_realpath());
-        return false;
+     if ((flags_ & FLAG_EXE) == 0) {
+             /*
+              * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
+              *
+              * Section 4.7.1.10 "Dynamic relocations"
+              * R_ARM_COPY may only appear in executable objects where e_type is
+              * set to ET_EXEC.
+              *
+              * TODO: FLAG_EXE is set for both ET_DYN and ET_EXEC executables.
+              * We should explicitly disallow ET_DYN executables from having
+              * R_ARM_COPY relocations.
+              */
+             //DL_ERR("%s R_ARM_COPY relocations only supported for ET_EXEC", name);
+             return false;
+         }
+         count_relocation(kRelocCopy);
+         MARK(rel->r_offset);
+         TRACE_TYPE(RELO, "RELO %08x <- %d @ %08x %s", reloc, s->st_size, sym_addr, sym_name);
+         if (reloc == sym_addr) {
+             const ElfW(Sym)* src;
+	     if(!soinfo_do_lookup(this, sym_name, vi, &lsi, global_group, local_group, &src))
+		return false;
+
+             if (src == NULL) {
+                 //DL_ERR("%s R_ARM_COPY relocation source cannot be resolved", name);
+                 return false;
+             }
+             if (lsi->has_DT_SYMBOLIC) {
+                 //DL_ERR("%s invalid R_ARM_COPY relocation against DT_SYMBOLIC shared "
+                  //      "library %s (built with -Bsymbolic?)", name, lsi->name);
+                 return false;
+             }
+             if (s->st_size < src->st_size) {
+                 //DL_ERR("%s R_ARM_COPY relocation size mismatch (%d < %d)",
+                 //       name, s->st_size, src->st_size);
+                 return false;
+             }
+             memcpy(reinterpret_cast<void*>(reloc),
+                    reinterpret_cast<void*>(src->st_value + lsi->load_bias), src->st_size);
+         } else {
+             //DL_ERR("%s R_ARM_COPY relocation target cannot be resolved", name);
+             return false;
+         }
+         break;
 #elif defined(__i386__)
       case R_386_32:
         count_relocation(kRelocRelative);
@@ -3007,20 +3077,20 @@ bool soinfo::link_image(const soinfo_list_t& global_group, const soinfo_list_t&
   if (has_text_relocations) {
     // Fail if app is targeting sdk version > 22
     // TODO (dimitry): remove != __ANDROID_API__ check once http://b/20020312 is fixed
-    if (get_application_target_sdk_version() != __ANDROID_API__
-        && get_application_target_sdk_version() > 22) {
-      PRINT("%s: has text relocations", get_realpath());
-      DL_ERR("%s: has text relocations", get_realpath());
-      return false;
-    }
+    //if (get_application_target_sdk_version() != __ANDROID_API__
+    //    && get_application_target_sdk_version() > 22) {
+    //  PRINT("%s: has text relocations", get_realpath());
+    //  DL_ERR("%s: has text relocations", get_realpath());
+      //return false;
+    //}
     // Make segments writable to allow text relocations to work properly. We will later call
     // phdr_table_protect_segments() after all of them are applied and all constructors are run.
-    DL_WARN("%s has text relocations. This is wasting memory and prevents "
-            "security hardening. Please fix.", get_realpath());
+    //DL_WARN("%s has text relocations. This is wasting memory and prevents "
+    //        "security hardening. Please fix.", get_realpath());
     if (phdr_table_unprotect_segments(phdr, phnum, load_bias) < 0) {
       DL_ERR("can't unprotect loadable segments for \"%s\": %s",
              get_realpath(), strerror(errno));
-      return false;
+      //return false;
     }
   }
 #endif
@@ -3276,13 +3346,13 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args, ElfW(
     }
   }
   si->dynamic = nullptr;
-
+/*
   ElfW(Ehdr)* elf_hdr = reinterpret_cast<ElfW(Ehdr)*>(si->base);
   if (elf_hdr->e_type != ET_DYN) {
     __libc_format_fd(2, "error: only position independent executables (PIE) are supported.\n");
     exit(EXIT_FAILURE);
   }
-
+*/
   // Use LD_LIBRARY_PATH and LD_PRELOAD (but only if we aren't setuid/setgid).
   parse_LD_LIBRARY_PATH(ldpath_env);
   parse_LD_PRELOAD(ldpreload_env);
-- 
1.9.1

